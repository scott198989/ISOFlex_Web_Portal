<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCM 3D Analytics</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        #canvas-container { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw; 
            height: 100vh;
            z-index: 0;
        }
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            pointer-events: none;
        }
        .glass {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            pointer-events: auto;
        }
        .metric-card {
            transition: all 0.3s ease;
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulse-glow {
            animation: pulse-glow 2s ease-in-out infinite;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-slide-up {
            animation: slideUp 0.3s ease-out;
        }
        .loading-spinner {
            border: 3px solid rgba(59, 130, 246, 0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-slate-950">
    <div id="canvas-container"></div>
    <div id="ui-overlay"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // Transform real NCM data to 3D visualization format
        const transformNCMData = (ncmData) => {
            // Group by line for spatial positioning
            const lineGroups = { A: [], B: [], C: [], OTHER: [] };
            
            ncmData.forEach((ncm, index) => {
                const line = ncm.line || 'OTHER';
                const group = lineGroups[line] || lineGroups.OTHER;
                group.push(ncm);
            });

            // Convert to 3D points with spatial clustering by line
            const points = [];
            let globalIndex = 0;

            Object.entries(lineGroups).forEach(([line, ncms], groupIndex) => {
                // Position each line group in different areas of 3D space
                const baseX = (groupIndex - 1.5) * 15; // Spread lines along X axis
                
                ncms.forEach((ncm, localIndex) => {
                    const rejectionRate = ncm.rejected_lbs / ncm.total_lbs;
                    const severity = Math.min(rejectionRate * 10, 10);
                    
                    // Cluster points within line group, height based on severity
                    const angle = (localIndex / ncms.length) * Math.PI * 2;
                    const radius = 5 + Math.random() * 3;
                    
                    points.push({
                        id: globalIndex++,
                        // Original NCM data
                        originalData: ncm,
                        // Mapped fields for visualization
                        process: ncm.line || 'Unknown',
                        defectType: ncm.ncm_type,
                        severity: severity,
                        frequency: ncm.rejected_lbs,
                        timestamp: new Date(ncm.date).getTime(),
                        resolved: ncm.status === 'CLOSED' || ncm.status === 'RESOLVED',
                        // 3D positioning
                        x: baseX + Math.cos(angle) * radius,
                        y: severity + Math.random() * 2,
                        z: Math.sin(angle) * radius,
                        baseY: severity + Math.random() * 2
                    });
                });
            });

            return points;
        };

        // Three.js Scene Manager
        class SceneManager {
            constructor(container, onPointClick) {
                this.container = container;
                this.onPointClick = onPointClick;
                this.data = [];
                this.dataPoints = [];
                this.selectedPoint = null;
                this.hoveredPoint = null;
                this.time = 0;

                this.initScene();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020617);
                this.scene.fog = new THREE.Fog(0x020617, 30, 60);

                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(25, 15, 25);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambientLight);

                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight1.position.set(10, 10, 5);
                this.scene.add(directionalLight1);

                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
                directionalLight2.position.set(-10, -10, -5);
                this.scene.add(directionalLight2);

                const gridHelper = new THREE.GridHelper(60, 60, 0x1e3a8a, 0x1e293b);
                this.scene.add(gridHelper);

                const ringGeometry = new THREE.TorusGeometry(20, 0.08, 16, 100);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3b82f6,
                    emissive: 0x3b82f6,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.3
                });
                this.ring = new THREE.Mesh(ringGeometry, ringMaterial);
                this.ring.rotation.x = Math.PI / 2;
                this.scene.add(this.ring);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                window.addEventListener('resize', () => this.onResize());
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
            }

            getColor(data) {
                if (data.resolved) {
                    return new THREE.Color(0.2, 0.8, 0.3);
                } else if (data.severity > 7) {
                    return new THREE.Color(1, 0.2, 0.2);
                } else if (data.severity > 4) {
                    return new THREE.Color(1, 0.7, 0.2);
                } else {
                    return new THREE.Color(0.3, 0.6, 1);
                }
            }

            updateData(newData) {
                this.dataPoints.forEach(point => {
                    this.scene.remove(point.group);
                });
                this.dataPoints = [];
                this.data = newData;

                newData.forEach(data => {
                    const group = new THREE.Group();
                    
                    const geometry = new THREE.SphereGeometry(0.4, 16, 16);
                    const color = this.getColor(data);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        roughness: 0.3,
                        metalness: 0.7
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    group.add(mesh);

                    const light = new THREE.PointLight(color, 0.5, 4);
                    group.add(light);

                    group.position.set(data.x, data.baseY, data.z);
                    group.userData = { data, mesh, light };
                    this.scene.add(group);
                    this.dataPoints.push(group);
                });

                this.updateConnections();
            }

            updateConnections() {
                if (this.lineGroup) {
                    this.scene.remove(this.lineGroup);
                }

                this.lineGroup = new THREE.Group();
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x3b82f6,
                    transparent: true,
                    opacity: 0.15
                });

                this.data.forEach((point, i) => {
                    this.data.slice(i + 1, i + 5).forEach(otherPoint => {
                        if (point.process === otherPoint.process && Math.random() > 0.7) {
                            const points = [
                                new THREE.Vector3(point.x, point.baseY, point.z),
                                new THREE.Vector3(otherPoint.x, otherPoint.baseY, otherPoint.z)
                            ];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, lineMaterial);
                            this.lineGroup.add(line);
                        }
                    });
                });

                this.scene.add(this.lineGroup);
            }

            setSelectedPoint(point) {
                this.selectedPoint = point;
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(
                    this.dataPoints.map(p => p.children[0])
                );

                if (this.hoveredPoint && this.hoveredPoint !== this.selectedPoint) {
                    const { mesh, light } = this.hoveredPoint.userData;
                    mesh.material.emissiveIntensity = 0.3;
                    light.intensity = 0.5;
                }

                if (intersects.length > 0) {
                    this.hoveredPoint = intersects[0].object.parent;
                    const { mesh, light } = this.hoveredPoint.userData;
                    mesh.material.emissiveIntensity = 0.8;
                    light.intensity = 2;
                    this.renderer.domElement.style.cursor = 'pointer';
                } else {
                    this.hoveredPoint = null;
                    this.renderer.domElement.style.cursor = 'default';
                }
            }

            onClick(event) {
                if (this.hoveredPoint) {
                    const data = this.hoveredPoint.userData.data;
                    this.onPointClick(data);
                }
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.time += 0.016;

                this.camera.position.x = Math.sin(this.time * 0.1) * 30;
                this.camera.position.z = Math.cos(this.time * 0.1) * 30;
                this.camera.position.y = 15 + Math.sin(this.time * 0.05) * 5;
                this.camera.lookAt(0, 5, 0);

                this.dataPoints.forEach((group) => {
                    const { data, mesh } = group.userData;
                    
                    group.position.y = data.baseY + Math.sin(this.time + data.id) * 0.1;
                    mesh.rotation.y += 0.01;

                    const isSpecial = group === this.selectedPoint || group === this.hoveredPoint;
                    const targetScale = isSpecial ? 1.5 : 1;
                    mesh.scale.lerp(
                        new THREE.Vector3(targetScale, targetScale, targetScale),
                        0.1
                    );
                });

                if (this.lineGroup) {
                    this.lineGroup.rotation.y = Math.sin(this.time * 0.1) * 0.1;
                }

                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                window.removeEventListener('resize', () => this.onResize());
                this.renderer.dispose();
                this.container.removeChild(this.renderer.domElement);
            }
        }

        // Stats Dashboard Component
        function StatsDashboard({ data, selectedPoint }) {
            const stats = useMemo(() => {
                const total = data.length;
                const resolved = data.filter(d => d.resolved).length;
                const critical = data.filter(d => d.severity > 7).length;
                const avgSeverity = (data.reduce((sum, d) => sum + d.severity, 0) / total).toFixed(2);
                
                const byProcess = {};
                data.forEach(d => {
                    byProcess[d.process] = (byProcess[d.process] || 0) + 1;
                });

                const totalRejected = data.reduce((sum, d) => sum + d.frequency, 0);

                return { total, resolved, critical, avgSeverity, byProcess, totalRejected };
            }, [data]);

            return (
                <div className="absolute top-4 left-4 space-y-4 z-10 pointer-events-auto">
                    <div className="glass rounded-xl p-4 text-white">
                        <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-400 to-cyan-400 bg-clip-text text-transparent">
                            NCM 3D Analytics
                        </h1>
                        <p className="text-sm text-slate-400">Real-time Manufacturing Data</p>
                    </div>

                    <div className="grid grid-cols-2 gap-3">
                        <div className="glass rounded-xl p-4 metric-card">
                            <div className="text-3xl font-bold text-blue-400">{stats.total}</div>
                            <div className="text-xs text-slate-400">Total NCMs</div>
                        </div>
                        <div className="glass rounded-xl p-4 metric-card">
                            <div className="text-3xl font-bold text-green-400">{stats.resolved}</div>
                            <div className="text-xs text-slate-400">Resolved</div>
                        </div>
                        <div className="glass rounded-xl p-4 metric-card">
                            <div className="text-3xl font-bold text-red-400">{stats.critical}</div>
                            <div className="text-xs text-slate-400">Critical</div>
                        </div>
                        <div className="glass rounded-xl p-4 metric-card">
                            <div className="text-3xl font-bold text-orange-400">{stats.totalRejected.toLocaleString()}</div>
                            <div className="text-xs text-slate-400">Total lbs Rejected</div>
                        </div>
                    </div>

                    <div className="glass rounded-xl p-4">
                        <h3 className="text-sm font-semibold text-white mb-3">By Line</h3>
                        {Object.entries(stats.byProcess).map(([process, count]) => (
                            <div key={process} className="mb-2">
                                <div className="flex justify-between text-xs mb-1">
                                    <span className="text-slate-300">Line {process}</span>
                                    <span className="text-slate-400">{count}</span>
                                </div>
                                <div className="w-full bg-slate-700 rounded-full h-1.5">
                                    <div 
                                        className="bg-gradient-to-r from-blue-500 to-cyan-400 h-1.5 rounded-full transition-all duration-500"
                                        style={{ width: `${(count / stats.total) * 100}%` }}
                                    />
                                </div>
                            </div>
                        ))}
                    </div>

                    <div className="glass rounded-xl p-4">
                        <h3 className="text-sm font-semibold text-white mb-3">Status</h3>
                        <div className="space-y-2 text-xs">
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded-full bg-green-500 pulse-glow" />
                                <span className="text-slate-300">Resolved/Closed</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded-full bg-red-500 pulse-glow" />
                                <span className="text-slate-300">Critical (&gt;70% reject)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded-full bg-orange-500" />
                                <span className="text-slate-300">Moderate (40-70%)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-3 h-3 rounded-full bg-blue-500" />
                                <span className="text-slate-300">Minor (&lt;40%)</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Detail Panel for Selected NCM
        function DetailPanel({ selectedPoint, onClose }) {
            if (!selectedPoint) return null;

            const ncm = selectedPoint.originalData;
            const rejectRate = ((ncm.rejected_lbs / ncm.total_lbs) * 100).toFixed(1);

            return (
                <div className="absolute bottom-4 left-4 right-4 glass rounded-xl p-6 text-white z-10 pointer-events-auto animate-slide-up">
                    <div className="flex justify-between items-start mb-4">
                        <div>
                            <h2 className="text-xl font-bold text-blue-400">NCM #{ncm.extrusion_number}</h2>
                            <p className="text-sm text-slate-400">Line {ncm.line} • {ncm.shift} Shift</p>
                        </div>
                        <button 
                            onClick={onClose}
                            className="text-slate-400 hover:text-white transition-colors"
                        >
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                        <div>
                            <div className="text-xs text-slate-400 mb-1">Customer</div>
                            <div className="text-lg font-semibold">{ncm.customer}</div>
                        </div>
                        <div>
                            <div className="text-xs text-slate-400 mb-1">NCM Type</div>
                            <div className="text-lg font-semibold">{ncm.ncm_type}</div>
                        </div>
                        <div>
                            <div className="text-xs text-slate-400 mb-1">Reject Rate</div>
                            <div className={`text-lg font-semibold ${
                                rejectRate > 70 ? 'text-red-400' : 
                                rejectRate > 40 ? 'text-orange-400' : 'text-blue-400'
                            }`}>
                                {rejectRate}%
                            </div>
                        </div>
                        <div>
                            <div className="text-xs text-slate-400 mb-1">Rejected</div>
                            <div className="text-lg font-semibold">{ncm.rejected_lbs.toLocaleString()} lbs</div>
                        </div>
                        <div>
                            <div className="text-xs text-slate-400 mb-1">Status</div>
                            <div className={`text-lg font-semibold ${selectedPoint.resolved ? 'text-green-400' : 'text-yellow-400'}`}>
                                {ncm.status}
                            </div>
                        </div>
                    </div>

                    <div className="mt-4 pt-4 border-t border-slate-700 grid grid-cols-2 gap-4">
                        <div>
                            <div className="text-xs text-slate-400">Total Weight</div>
                            <div className="text-sm">{ncm.total_lbs.toLocaleString()} lbs</div>
                        </div>
                        <div>
                            <div className="text-xs text-slate-400">Disposition</div>
                            <div className="text-sm">{ncm.disposition}</div>
                        </div>
                    </div>

                    <div className="mt-4 pt-4 border-t border-slate-700">
                        <div className="text-xs text-slate-400">
                            Date: {new Date(ncm.date).toLocaleDateString()}
                        </div>
                    </div>
                </div>
            );
        }

        // Loading Component
        function LoadingScreen() {
            return (
                <div className="absolute inset-0 flex items-center justify-center bg-slate-950 z-50">
                    <div className="text-center">
                        <div className="loading-spinner mx-auto mb-4"></div>
                        <div className="text-white text-xl font-semibold">Loading NCM Data...</div>
                        <div className="text-slate-400 text-sm mt-2">Initializing 3D visualization</div>
                    </div>
                </div>
            );
        }

        // Main App Component
        function App() {
            const [data, setData] = useState([]);
            const [selectedPoint, setSelectedPoint] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const sceneManagerRef = useRef(null);

            useEffect(() => {
                // Fetch real NCM data from API
                const fetchData = async () => {
                    try {
                        setLoading(true);
                        const response = await fetch('/data');
                        if (!response.ok) throw new Error('Failed to fetch NCM data');
                        
                        const ncmData = await response.json();
                        const transformedData = transformNCMData(ncmData);
                        setData(transformedData);

                        // Initialize Three.js scene
                        const container = document.getElementById('canvas-container');
                        sceneManagerRef.current = new SceneManager(container, (point) => {
                            setSelectedPoint(point);
                        });
                        sceneManagerRef.current.updateData(transformedData);
                        
                        setLoading(false);
                    } catch (err) {
                        console.error('Error fetching NCM data:', err);
                        setError(err.message);
                        setLoading(false);
                    }
                };

                fetchData();

                // Refresh data every 30 seconds
                const interval = setInterval(fetchData, 30000);

                return () => {
                    clearInterval(interval);
                    if (sceneManagerRef.current) {
                        sceneManagerRef.current.dispose();
                    }
                };
            }, []);

            useEffect(() => {
                if (sceneManagerRef.current) {
                    const selectedGroup = sceneManagerRef.current.dataPoints.find(
                        p => p.userData.data.id === selectedPoint?.id
                    );
                    sceneManagerRef.current.setSelectedPoint(selectedGroup);
                }
            }, [selectedPoint]);

            if (loading) {
                return <LoadingScreen />;
            }

            if (error) {
                return (
                    <div className="absolute inset-0 flex items-center justify-center bg-slate-950">
                        <div className="glass rounded-xl p-8 text-center max-w-md">
                            <div className="text-red-400 text-xl font-bold mb-2">Error Loading Data</div>
                            <div className="text-slate-300">{error}</div>
                            <button 
                                onClick={() => window.location.reload()}
                                className="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors"
                            >
                                Retry
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <>
                    <StatsDashboard data={data} selectedPoint={selectedPoint} />
                    <DetailPanel 
                        selectedPoint={selectedPoint} 
                        onClose={() => setSelectedPoint(null)}
                    />

                    {/* Back to Dashboard Button */}
                    <div className="absolute top-4 right-4 pointer-events-auto">
                        <a 
                            href="/"
                            className="glass rounded-lg px-4 py-2 text-sm text-white hover:bg-slate-700 transition-colors flex items-center gap-2"
                        >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                            Back to Dashboard
                        </a>
                    </div>

                    {/* Controls hint */}
                    <div className="absolute bottom-4 right-4 glass rounded-lg px-4 py-2 text-xs text-slate-400 pointer-events-none">
                        Click points for details • Auto-rotating camera • Data refreshes every 30s
                    </div>
                </>
            );
        }

        ReactDOM.render(<App />, document.getElementById('ui-overlay'));
    </script>
</body>
</html>